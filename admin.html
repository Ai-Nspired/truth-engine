<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Truth Engine Admin Console - Creator Edition</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <style>
    /* (styles unchanged from your version, omitted here for brevity) */
    /* KEEP all your CSS here exactly as you had it */
  </style>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.8.0/styles/github-dark.min.css">
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/highlight.js@11.8.0/lib/highlight.min.js"></script>
</head>
<body data-output-mode="silvery">
  <div class="glasscard" id="melody-lock">
    <h2>ðŸ”’ Admin Melody Lock</h2>
    <div class="melody-instructions">
      <b>Step 1:</b> Play your secret melody or paste its pattern.<br>
      <b>Step 2:</b> Click <b>Unlock Admin</b>.<br>
      <div style="font-size:0.95em;margin-top:7px;opacity:0.87;">
        (To share access: use <code>Export Pattern</code> from your melody tool)
      </div>
    </div>
    <div id="melody-piano"></div>
    <div class="melody-btns">
      <button id="melody-clear">Clear Melody</button>
      <button id="melody-unlock">Unlock Admin</button>
    </div>
    <div id="melody-bar"></div>
    <div class="import-group">
      <input type="text" id="importMelodyInput" placeholder="Pattern e.g. 40-43-45">
      <button id="importMelodyBtn">Import</button>
    </div>
    <div id="melody-status"></div>
  </div>

  <div class="admin-container" id="admin-container">
    <h2>Truth Engine Admin Console</h2>
    
    <div id="editor-tab" class="tab-content active">
      <label for="query">Query (exact):</label>
      <input type="text" id="query" placeholder="e.g. what is this?">
      <div class="button-group">
        <button id="loadBtn">Load</button>
        <button id="clearEditorBtn">Clear</button>
      </div>
      <div id="loadMsg" class="status-message"></div>

      <label for="answer">Answer (Markdown, HTML, CSS, and iFrames supported):</label>
      
      <!-- helpers unchanged -->
      <div class="creation-helpers-section">
        <!-- ... your helper UI unchanged ... -->
      </div>

      <textarea id="answer" placeholder="Write your truth here..."></textarea>

      <div class="audit-fields">
        <label for="editor">Your Name (for audit):</label>
        <input type="text" id="editor" placeholder="admin">
        <div style="grid-column: 1 / span 2; margin-top: 5px;">
          <label>Citations (Title & URL):</label>
          <div class="citations-container" style="margin-top: 0;">
            <input type="text" placeholder="Title 1" class="citation-title">
            <input type="text" placeholder="URL 1" class="citation-url">
            <input type="text" placeholder="Title 2" class="citation-title">
            <input type="text" placeholder="URL 2" class="citation-url">
          </div>
        </div>
      </div>
      
      <div class="button-group">
        <button id="saveBtn">Save</button>
        <button id="copyPreviewBtn">Copy Output</button>
        <button id="togglePreviewBtn" onclick="togglePreview()">Toggle Preview</button>
      </div>
      <div id="saveMsg" class="status-message"></div>

      <div class="preview-wrapper" id="previewWrapper">
        <label>Preview (Live Render):</label>
        <div class="preview" id="preview"></div>
        <div class="content-length" id="contentLength">Character count: 0</div>
      </div>
    </div>
    
    <div class="admin-footer">Â© 2025 truth-network admin console</div>
  </div>

  <script>
    // MARKED/HIGHLIGHT CONFIG
    marked.setOptions({
      highlight: function(code, lang) {
        if (lang && hljs.getLanguage(lang)) {
          return hljs.highlight(code, { language: lang }).value;
        }
        return hljs.highlightAuto(code).value;
      }
    });

    // ========= Melody Lock (unchanged logic, just gating UI) =========
    const allowedMelodyHash = "e4a25ba5b1c669414746d9efdc533019e14bf8a86c288165de44bdcf791d4cfa";
    let melody = [];

    function renderPiano() {
      const notes = [60,62,64,65,67,69,71];
      const names = ['C','D','E','F','G','A','B'];
      const piano = document.getElementById('melody-piano');
      piano.innerHTML = '';
      notes.forEach((note, i) => {
        const btn = document.createElement('div');
        btn.className = 'melody-key';
        btn.dataset.note = note;
        btn.textContent = names[i];
        btn.onclick = () => {
          playNote(note);
          melody.push(note);
          updateMelodyBar();
          btn.classList.add('active');
          setTimeout(()=>btn.classList.remove('active'),120);
        };
        piano.appendChild(btn);
      });
    }

    function playNote(midi) {
      try {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const freq = 440 * Math.pow(2, (midi-69)/12);
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = 'sine';
        o.frequency.value = freq;
        g.gain.setValueAtTime(0.12, ctx.currentTime);
        g.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.21);
        o.connect(g).connect(ctx.destination);
        o.start();
        o.stop(ctx.currentTime + 0.21);
        o.onended = () => ctx.close();
      } catch(e) {}
    }

    function updateMelodyBar() {
      const bar = document.getElementById('melody-bar');
      bar.innerHTML = '';
      melody.forEach(m => {
        const span = document.createElement('span');
        span.className = 'melody-pill';
        span.textContent = noteName(m);
        bar.appendChild(span);
      });
    }

    function noteName(midi) {
      const n=['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
      return n[midi%12]+Math.floor(midi/12-1);
    }

    document.getElementById('melody-clear').onclick = () => {
      melody = [];
      updateMelodyBar();
      document.getElementById('melody-status').textContent = '';
    };

    document.getElementById('melody-unlock').onclick = async () => {
      if (!melody.length) {
        document.getElementById('melody-status').textContent = 'Play or import your melody!';
        return;
      }
      const bytes = new Uint8Array(melody);
      const hashBuf = await crypto.subtle.digest('SHA-256', bytes);
      const hashFull = Array.from(new Uint8Array(hashBuf))
        .map(b=>b.toString(16).padStart(2,'0')).join('');
      if (hashFull === allowedMelodyHash) {
        document.getElementById('melody-lock').style.display = 'none';
        document.getElementById('admin-container').style.display = 'block';
      } else {
        document.getElementById('melody-status').textContent = 'Incorrect melody, try again.';
      }
    };

    document.getElementById('importMelodyBtn').onclick = () => {
      const pat = document.getElementById('importMelodyInput').value.trim();
      if (!pat) return;
      melody = pat.split('-').map(x=>parseInt(x, 36)).filter(x=>!isNaN(x));
      updateMelodyBar();
      document.getElementById('melody-status').textContent = '';
    };

    renderPiano();

    // ========= Preview / Theme =========
    function setMode(mode) {
      document.body.setAttribute('data-output-mode', mode);
      answerInput.dispatchEvent(new Event('input'));
    }

    function togglePreview() {
      const previewWrapper = document.getElementById('previewWrapper');
      const textareaEl = document.getElementById('answer');
      const toggleBtn = document.getElementById('togglePreviewBtn');
      const isHidden = previewWrapper.style.display === 'none';
      if (isHidden) {
        previewWrapper.style.display = 'block';
        textareaEl.style.minHeight = '150px';
        toggleBtn.textContent = 'Toggle Preview';
      } else {
        previewWrapper.style.display = 'none';
        textareaEl.style.minHeight = '350px';
        toggleBtn.textContent = 'Show Preview';
      }
    }

    // ========= Admin Editor Logic (wired to TRUTH worker) =========

    // CHANGE THIS to your actual TRUTH orchestrator URL
    const API_BASE = "https://truth.ai-n.workers.dev"; 

    const queryInput = document.getElementById('query');
    const answerInput = document.getElementById('answer');
    const editorInput = document.getElementById('editor');
    const loadBtn = document.getElementById('loadBtn');
    const saveBtn = document.getElementById('saveBtn');
    const loadMsg = document.getElementById('loadMsg');
    const saveMsg = document.getElementById('saveMsg');
    const previewDiv = document.getElementById('preview');
    const citationTitles = document.querySelectorAll('.citation-title');
    const citationUrls = document.querySelectorAll('.citation-url');

    // Track current record metadata so Save knows which endpoint to use
    let currentLayer = null;    // "master" | "provisional" | null
    let currentId = null;       // normalized id

    answerInput.addEventListener('input', () => {
      const content = answerInput.value || '';
      previewDiv.innerHTML = marked.parse(content);
      document.querySelectorAll('#preview pre code').forEach(block => {
        hljs.highlightElement(block);
      });
      const charCount = content.length;
      const contentLengthDiv = document.getElementById('contentLength');
      contentLengthDiv.textContent = `Character count: ${charCount}`;
      if (charCount > 8000) {
        contentLengthDiv.classList.add('warning');
        contentLengthDiv.textContent += " (Very long content may be truncated)";
      } else {
        contentLengthDiv.classList.remove('warning');
      }
    });

    document.getElementById('copyPreviewBtn').onclick = () => {
      const preview = document.getElementById('preview');
      const range = document.createRange();
      range.selectNodeContents(preview);
      const selection = window.getSelection();
      selection.removeAllRanges();
      selection.addRange(range);
      try {
        document.execCommand('copy');
        selection.removeAllRanges();
        alert('Output copied!');
      } catch (err) {
        alert('Copy failed');
      }
    };

    document.getElementById('clearEditorBtn').onclick = () => {
      if (confirm('Clear all editor content?')) {
        answerInput.value = '';
        queryInput.value = '';
        previewDiv.innerHTML = '';
        citationTitles.forEach(e => e.value = '');
        citationUrls.forEach(e => e.value = '');
        loadMsg.textContent = '';
        saveMsg.textContent = '';
        currentLayer = null;
        currentId = null;
        answerInput.dispatchEvent(new Event('input'));
      }
    };

    // Load: use TRUTH /api/truth/resolve
    loadBtn.onclick = async () => {
      loadMsg.textContent = '';
      saveMsg.textContent = '';
      currentLayer = null;
      currentId = null;
      const input = queryInput.value.trim();
      if (!input) {
        loadMsg.textContent = "Enter a query.";
        return;
      }
      loadMsg.textContent = "Loading...";
      answerInput.value = '';
      previewDiv.innerHTML = '';
      citationTitles.forEach(e => e.value = '');
      citationUrls.forEach(e => e.value = '');

      try {
        const resp = await fetch(`${API_BASE}/api/truth/resolve`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ input })
        });
        const data = await resp.json();
        if (!resp.ok) {
          loadMsg.textContent = `Error: ${data.error || resp.status}`;
          return;
        }

        if (data.answer) {
          answerInput.value = data.answer;
          answerInput.dispatchEvent(new Event('input'));

          // layer: "master"|"provisional"|"none"
          currentLayer = data.layer || null;
          currentId = data.id || null;

          // Try to load citations if present
          if (data.meta && Array.isArray(data.meta.citations)) {
            data.meta.citations.slice(0, 2).forEach((c, i) => {
              citationTitles[i].value = c.title || '';
              citationUrls[i].value = c.url || '';
            });
          }

          if (currentLayer === "master") {
            loadMsg.textContent = `Loaded MASTER truth (${currentId || 'id unknown'})`;
          } else if (currentLayer === "provisional") {
            loadMsg.textContent = `Loaded PROVISIONAL truth (${currentId || 'id unknown'})`;
          } else {
            loadMsg.textContent = "Loaded candidate/miss. You can create a truth from this.";
          }

        } else {
          loadMsg.textContent = "No answer found. You can create one.";
        }

      } catch (e) {
        loadMsg.textContent = "Error loading: " + e.message;
      }
    };

    // Save: route to master/provisional endpoints based on currentLayer
    saveBtn.onclick = async () => {
      saveMsg.textContent = '';
      const input = queryInput.value.trim();
      const answer = answerInput.value;
      const editor = (editorInput.value.trim() || "admin");
      localStorage.setItem('lastEditorName', editor);

      if (!input || !answer) {
        saveMsg.textContent = "Query and answer required.";
        return;
      }

      // collect citations
      const citations = [];
      for (let i = 0; i < 2; i++) {
        const title = citationTitles[i].value.trim();
        const url = citationUrls[i].value.trim();
        if (title && url) citations.push({ title, url });
      }

      saveMsg.textContent = "Saving...";

      try {
        let endpoint = "";
        let body = {};

        // Decide: if loaded from master â†’ update master.
        // If loaded from provisional or nothing â†’ update/create provisional.
        if (currentLayer === "master") {
          endpoint = `${API_BASE}/api/truth/master/update`;
          body = {
            input,
            answer,
            editor,
            meta: {
              citations
            }
          };
        } else {
          // provisional create-or-update
          endpoint = `${API_BASE}/api/truth/provisional/update`;
          body = {
            idOrQuery: input,
            answer,
            meta: {
              editor,
              citations
            }
          };
        }

        const resp = await fetch(endpoint, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body)
        });

        const data = await resp.json().catch(() => ({}));

        if (!resp.ok) {
          saveMsg.textContent = `Save failed: ${data.error || resp.status}`;
          return;
        }

        if (currentLayer === "master") {
          saveMsg.textContent = "MASTER truth updated successfully.";
        } else {
          saveMsg.textContent = "PROVISIONAL truth saved/updated successfully.";
          currentLayer = "provisional";
          currentId = data.id || currentId;
        }

      } catch (e) {
        saveMsg.textContent = "Error saving: " + e.message;
      }
    };

    // Markdown helpers (unchanged from your version)
    function insertMarkdown(text, before, after) {
      const start = answerInput.selectionStart;
      const end = answerInput.selectionEnd;
      const selected = answerInput.value.substring(start, end);
      const replacement = before + (selected || text) + after;
      answerInput.value =
        answerInput.value.substring(0, start) +
        replacement +
        answerInput.value.substring(end);
      answerInput.focus();
      answerInput.selectionStart = start + before.length;
      answerInput.selectionEnd = start + before.length + (selected || text).length;
      answerInput.dispatchEvent(new Event('input'));
    }

    function insertIframe() {
      const iframeCode =
        '\n<iframe src="https://example.com" style="border:1px solid var(--truth-accent-light); width:100%; height:300px;"></iframe>\n';
      answerInput.value += iframeCode;
      answerInput.dispatchEvent(new Event('input'));
      answerInput.focus();
    }

    function removeExtraWhitespace() {
      const content = answerInput.value;
      const cleaned = content
        .split('\n').map(l => l.trim()).join('\n')
        .replace(/\n\n\n+/g, '\n\n');
      answerInput.value = cleaned;
      answerInput.dispatchEvent(new Event('input'));
      alert('Whitespace cleaned!');
    }

    function addBlock() {
      const style = document.getElementById('style-select').value;
      let htmlSnippet = '';
      // (unchanged block snippets)
      // ...
      // Append snippet:
      answerInput.value += htmlSnippet;
      answerInput.dispatchEvent(new Event('input'));
      answerInput.focus();
    }

    // Initialize editor
    (function initializeEditor() {
      const lastEditor = localStorage.getItem('lastEditorName');
      if (lastEditor) editorInput.value = lastEditor;
      answerInput.dispatchEvent(new Event('input'));
    })();
  </script>
</body>
</html>